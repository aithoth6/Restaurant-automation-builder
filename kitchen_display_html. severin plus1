// ============================================
// SEVERINA KITCHEN DISPLAY - GOOGLE APPS SCRIPT
// ============================================

// CONFIGURATION
const CONFIG = {
  SHEET_ID: '1RyMQ_73Gm9ub6EccABapzn9JgDra_79LZCX6ko_2KbU',
  ORDERS_SHEET_NAME: 'ORDERING_SHEET',
  TIMEZONE: 'GMT',
  N8N_WEBHOOK_URL: 'https://n8n.srv1186827.hstgr.cloud/webhook/kitchen-ready', // Leave empty for now, add later when you set up n8n
};

// ============================================
// WEB APP HANDLERS
// ============================================

// Handle GET requests (serve HTML page and get orders)
function doGet(e) {
  const action = e.parameter.action;
  
  if (action === 'getOrders') {
    return getOrders();
  }
  
  // Serve the HTML page
  return HtmlService.createHtmlOutputFromFile('kitchen_display')
    .setTitle('Severina Kitchen Display')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

// Handle GET requests (button actions)
// Handle GET requests (serve HTML page and handle all actions)
function doGet(e) {
  const action = e.parameter.action;
  
  if (action === 'getOrders') {
    return getOrders();
  }
  
  if (action === 'startCooking') {
    const orderId = e.parameter.orderId;
    const staff = e.parameter.staff;
    return startCooking(orderId, staff);
  }
  
  if (action === 'markReady') {
    const orderId = e.parameter.orderId;
    return markReady(orderId);
  }
  
  // Serve the HTML page
  return HtmlService.createHtmlOutputFromFile('kitchen_display')
    .setTitle('Severina Kitchen Display')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

// ============================================
// ORDER MANAGEMENT FUNCTIONS
// ============================================

// Get all orders (Pending and In Progress)
function getOrders() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.ORDERS_SHEET_NAME);
    
    if (!sheet) {
      throw new Error('Sheet not found: ' + CONFIG.ORDERS_SHEET_NAME);
    }
    
    const data = sheet.getDataRange().getValues();
    
    // Return empty if only headers
    if (data.length <= 1) {
      return ContentService.createTextOutput(JSON.stringify({
        pending: [],
        cooking: [],
        timestamp: new Date().toISOString()
      })).setMimeType(ContentService.MimeType.JSON);
    }
    
    const headers = data[0];
    
    // Find column indices
    const colIndices = {};
    headers.forEach((header, index) => {
      colIndices[header] = index;
    });
    
    const pending = [];
    const cooking = [];
    
    // Process rows (skip header)
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const status = row[colIndices.STATUS];
      
      // Skip if no ORDER_ID (empty row)
      if (!row[colIndices.ORDER_ID]) continue;
      
      // Only include Pending or In Progress orders
      if (status === 'Pending' || status === 'In Progress') {
        const order = {
          rowIndex: i + 1, // Store row index for updates
          orderId: row[colIndices.ORDER_ID] || '',
          customerName: row[colIndices.CUSTOMER_NAME] || '',
          phone: row[colIndices.PHONE] || '',
          items: row[colIndices.ITEMS] || '',
          quantity: row[colIndices.QUANTITY] || '',
          deliveryOption: row[colIndices.DELIVERY_OPTION] || '',
          amount: row[colIndices.AMOUNT] || '',
          time: row[colIndices.TIME] || '',
          date: row[colIndices.DATE] || '',
          status: status,
          acceptedBy: row[colIndices.ACCEPTED_BY] || '',
          acceptedAt: row[colIndices.ACCEPTED_AT] || '',
           updated: row[colIndices.ORDER_UPDATED] === 'YES'
        };
        
        if (status === 'Pending') {
          pending.push(order);
        } else {
          cooking.push(order);
        }
      }
    }
    
    const result = {
      pending: pending,
      cooking: cooking,
      timestamp: new Date().toISOString()
    };
    
    return ContentService.createTextOutput(JSON.stringify(result))
      .setMimeType(ContentService.MimeType.JSON);
      
  } catch (error) {
    Logger.log('Error in getOrders: ' + error.toString());
    return ContentService.createTextOutput(JSON.stringify({ 
      pending: [], 
      cooking: [], 
      error: error.toString() 
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

// Start cooking an order
function startCooking(orderId, staff) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.ORDERS_SHEET_NAME);
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find column indices
    const colIndices = {};
    headers.forEach((header, index) => {
      colIndices[header] = index;
    });
    
    // Find the order row
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      if (row[colIndices.ORDER_ID] === orderId && row[colIndices.STATUS] === 'Pending') {
        const rowNum = i + 1;
        
        // Update STATUS to "In Progress"
        sheet.getRange(rowNum, colIndices.STATUS + 1).setValue('In Progress');
        
        // Set ACCEPTED_BY
        sheet.getRange(rowNum, colIndices.ACCEPTED_BY + 1).setValue(staff);
        
        // Set ACCEPTED_AT timestamp
        const timestamp = new Date();
        const formattedTime = Utilities.formatDate(timestamp, CONFIG.TIMEZONE, 'yyyy-MM-dd HH:mm:ss');
        sheet.getRange(rowNum, colIndices.ACCEPTED_AT + 1).setValue(formattedTime);
        
        Logger.log('Order ' + orderId + ' started by ' + staff);
        
        return ContentService.createTextOutput(JSON.stringify({ 
          success: true,
          orderId: orderId,
          staff: staff
        })).setMimeType(ContentService.MimeType.JSON);
      }
    }
    
    throw new Error('Order not found or already in progress');
    
  } catch (error) {
    Logger.log('Error in startCooking: ' + error.toString());
    return ContentService.createTextOutput(JSON.stringify({ 
      success: false, 
      error: error.toString() 
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

// Mark order as ready
function markReady(orderId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.ORDERS_SHEET_NAME);
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find column indices
    const colIndices = {};
    headers.forEach((header, index) => {
      colIndices[header] = index;
    });
    
    // Find the order row
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      if (row[colIndices.ORDER_ID] === orderId && row[colIndices.STATUS] === 'In Progress') {
        const rowNum = i + 1;
        
        // Update STATUS to "Ready"
        sheet.getRange(rowNum, colIndices.STATUS + 1).setValue('Ready');
        
        // Set READY_AT timestamp
        const timestamp = new Date();
        const formattedTime = Utilities.formatDate(timestamp, CONFIG.TIMEZONE, 'yyyy-MM-dd HH:mm:ss');
        sheet.getRange(rowNum, colIndices.READY_AT + 1).setValue(formattedTime);
        
        Logger.log('Order ' + orderId + ' marked as ready');
        
        // Get order details for webhook (if n8n is configured)
        if (CONFIG.N8N_WEBHOOK_URL) {
          const orderData = {
            orderId: orderId,
            customerName: row[colIndices.CUSTOMER_NAME],
            phone: row[colIndices.PHONE],
            items: row[colIndices.ITEMS],
            quantity: row[colIndices.QUANTITY],
            deliveryOption: row[colIndices.DELIVERY_OPTION],
            amount: row[colIndices.AMOUNT],
            acceptedBy: row[colIndices.ACCEPTED_BY],
            readyAt: formattedTime
          };
          
          // Trigger n8n webhook
          triggerN8nWebhook(orderData);
        }
        
        return ContentService.createTextOutput(JSON.stringify({ 
          success: true,
          orderId: orderId
        })).setMimeType(ContentService.MimeType.JSON);
      }
    }
    
    throw new Error('Order not found or not in progress');
    
  } catch (error) {
    Logger.log('Error in markReady: ' + error.toString());
    return ContentService.createTextOutput(JSON.stringify({ 
      success: false, 
      error: error.toString() 
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

// ============================================
// N8N WEBHOOK INTEGRATION (Optional)
// ============================================

// Trigger n8n webhook when order is ready
function triggerN8nWebhook(orderData) {
  if (!CONFIG.N8N_WEBHOOK_URL) {
    Logger.log('N8N webhook not configured, skipping');
    return;
  }
  
  try {
    const options = {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify({
        event: 'order_ready',
        data: orderData
      }),
      muteHttpExceptions: true
    };
    
    const response = UrlFetchApp.fetch(CONFIG.N8N_WEBHOOK_URL, options);
    Logger.log('Webhook triggered successfully: ' + response.getContentText());
    
  } catch (error) {
    Logger.log('Error triggering webhook: ' + error.toString());
    // Don't throw - we don't want to fail the order update if webhook fails
  }
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

// Test function to verify setup
function testSetup() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.ORDERS_SHEET_NAME);
    
    if (!sheet) {
      Logger.log('ERROR: Sheet not found - ' + CONFIG.ORDERS_SHEET_NAME);
      return false;
    }
    
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    Logger.log('✅ Sheet found! Headers: ' + headers.join(', '));
    
    // Check required columns
    const requiredColumns = [
      'ORDER_ID', 'PHONE', 'CUSTOMER_NAME', 'ITEMS', 'QUANTITY', 
      'DELIVERY_OPTION', 'AMOUNT', 'STATUS', 'DATE', 'TIME',
      'ACCEPTED_BY', 'ACCEPTED_AT', 'READY_AT'
    ];
    
    const missingColumns = [];
    
    requiredColumns.forEach(col => {
      if (!headers.includes(col)) {
        missingColumns.push(col);
      }
    });
    
    if (missingColumns.length > 0) {
      Logger.log('⚠️ WARNING: Missing columns: ' + missingColumns.join(', '));
      Logger.log('Please add these columns to your sheet!');
    } else {
      Logger.log('✅ SUCCESS: All required columns present!');
    }
    
    return true;
    
  } catch (error) {
    Logger.log('❌ ERROR in testSetup: ' + error.toString());
    return false;
  }
}

// Test HTML file loading
function testHtmlFile() {
  try {
    const html = HtmlService.createHtmlOutputFromFile('kitchen_display');
    const content = html.getContent();
    
    Logger.log('✅ SUCCESS! HTML file loaded.');
    Logger.log('First 200 chars: ' + content.substring(0, 200));
    Logger.log('Total length: ' + content.length + ' characters');
    
    if (content.startsWith('<!DOCTYPE html>')) {
      Logger.log('✅ HTML starts with correct DOCTYPE');
    } else {
      Logger.log('⚠️ WARNING: HTML does not start with DOCTYPE');
      Logger.log('Actually starts with: ' + content.substring(0, 50));
    }
    
    return true;
    
  } catch (error) {
    Logger.log('❌ ERROR loading HTML file:');
    Logger.log(error.toString());
    return false;
  }
}
function debugGetOrders() {
  const result = getOrders();
  const content = result.getContent();
  Logger.log('Result: ' + content);
  
  const data = JSON.parse(content);
  Logger.log('Pending orders: ' + data.pending.length);
  Logger.log('Cooking orders: ' + data.cooking.length);
  
  if (data.pending.length > 0) {
    Logger.log('First pending order: ' + JSON.stringify(data.pending[0]));
  }
}
function simpleTest() {
  Logger.log('=== STARTING TEST ===');
  
  const ss = SpreadsheetApp.openById(CONFIG.SHEET_ID);
  Logger.log('Sheet opened');
  
  const sheet = ss.getSheetByName(CONFIG.ORDERS_SHEET_NAME);
  Logger.log('Sheet found: ' + sheet.getName());
  
  const data = sheet.getDataRange().getValues();
  Logger.log('Total rows: ' + data.length);
  
  const headers = data[0];
  Logger.log('Headers: ' + headers.join(', '));
  
  if (data.length > 1) {
    Logger.log('Row 2 data: ' + data[1].join(' | '));
    
    // Find STATUS column
    const statusIndex = headers.indexOf('STATUS');
    Logger.log('STATUS column index: ' + statusIndex);
    Logger.log('STATUS value in row 2: "' + data[1][statusIndex] + '"');
  }
  
  Logger.log('=== TEST COMPLETE ===');
}
